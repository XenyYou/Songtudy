**05/07 수요일**

백준에 있는 삼성 기출 문제집에서 '아기 상어' 문제를 풀이했다.
물고기 먹는 우선순위가 (최단 거리 → 가장 위 → 가장 왼쪽)이므로, BFS 탐색 시 (거리, y, x) 순으로 fishes에 저장하고 sort()로 정렬해야 했다.

한 번의 BFS로 모든 후보 물고기를 탐색한 뒤 가장 우선순위 높은 것만 선택하는 방식이며, min_dist로 가지치기를 해야 불필요한 탐색을 줄일 수 있었다.
(약간 dijkstra에서 가지치기 하듯이..?)

삼성 기출에서 자주 나오는 구현 + BFS 조합의 대표적인 문제 유형인 것 같았다.

***

**05/08 목요일**

프로그래머스 PCCP 기출 문제집에서 lv2 난이도의 '충돌위험 찾기' 문제를 풀이했다.
싸피에서부터 bfs로 접근해서 풀이하려고 해봤지만, 계속 시간초과 에러가 나서 정답을 도출해낼 수 없었다.
그래서 bfs로 경로를 구하는 것 보다, 로봇 이동 좌표를 딕셔너리(defaultdict) 형태로 저장해 Counter 자료형을 사용해서 같은 시간대에 해당 위치에 몇개의 로봇이 있는 지 확인하고 2대 이상일 경우 total +=1 하는 방식으로 풀이했다.

그동안 collenctions에서는 deque만 import하고 다른 자료형은 써본 적이 없었는데, 이번 기회를 통해 defaultdict와 Counter도 유용하게 쓰일 수 있다는 것을 알게됐고, 앞으로 코딩테스트를 대비할 때 다양한 방법으로 풀이해봐야 겠다는 생각이 들었다.

- defaultdict(list)
: timeline[3].append((x, y))처럼 key가 3인 값이 없다면, 일반 딕셔너리는 에러를 내지만 defaultdict는 자동으로 {3:[(x,y)]}를 만들어줌

- Counter
: c = Counter(['a', 'b', 'a', 'c', 'a', 'b'])
: print(c) 결과 = Counter({'a': 3, 'b': 2, 'c': 1})

***

**05/09 금요일**

스터디 공통문제 '순열 사이클' 풀이.

***

**05/10 토요일**

백준의 백트래킹 문제인 '연산자 끼워넣기'를 풀이했다.
예전에 SWEA에서 유사한 문제를 풀었던 기억이 나서, 복습하는 느낌이 들었다.
특히 파이썬에서의 음수 나눗셈 처리를 주의해야 했는데,
예를 들어 -3 / 2는 -1.5가 되는데, // 연산자는 이를 내림 처리해 -2가 되어 if문 처리가 필요했다.

***

**05/11 일요일**

스터디 공통문제 '신입 사원' 풀이.

1차 서류, 2차 면접 둘 중 아무거나를 기준으로 잡고 정렬한 다음 정렬 안된 값으로 비교하면서 뽑으면 됨
다른 지원자보다 무조건 값 1개는 높아야 하므로, 정렬된 인덱스는 이미 순위를 나타냄(1차 or 2차 순위)
정렬이 안 된 다른 값을 기준으로 min_v보다 높은 순위(작은 숫자)를 가지고 있는 지원자를 뽑으면 됨.

알고리즘 분류에 그리디 + **정렬**이라고 써져있음.. 너무 대놓고 힌트인 거 같긴 함